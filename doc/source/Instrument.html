<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='C-Instrument'>/**
</span> * Basic Instrument class
 * 
 * @class 
 * @extends C.Class
 */
C.Instrument = C.Class.extend({
    options: {
	numFrets: -1,
	description: &quot;&quot;,
	maxFretSpan: 4,	// Inclusive distance
	renderer: null
    },
    
<span id='C-Instrument-method-initialize'>    /**
</span>     * Base init function. Creates the chord cache structure
     * 
     * @param {Object} options
     */
    initialize: function (options) {
	C.setOptions(this, options);
	
	// Chord Data: TODO: Make Object to have functions?
	this.c = {
	    // Chord set to the instrument
	    chord: &quot;&quot;,
	    // Chord notes
	    notes: [],
	    // Chord formula
	    form: &quot;&quot;,
	    // Formula split
	    fsplit: [],
	    // Chord sub-notes on each string
	    fpos: [],
	    // Final chord positions
	    pos: [],
	    
	    // Diagram data
	    diag: {
		el: null,
		idx: -1
	    },
	    // 9ths,11ths,13ths
	    th9: false,
	    th11: false,
	    th13: false
	};

	
	
    },
    
<span id='C-Instrument-method-getNumStrings'>    /**
</span>     * Return the number of strings
     * 
     * @return {Number}
     */
    getNumStrings: function(){
	return  this.options.strings.length;
    },
    
    
<span id='C-Instrument-method-getName'>    /**
</span>     * Return the instruments name
     * 
     * @return {String}
     */
    getName: function(){
	return this.options.name;
    },
    
<span id='C-Instrument-method-getDescription'>    /**
</span>     * Return the instruments description
     * 
     * @return {String}
     */
    getDescription: function(){
	return this.options.description;
    },
    
<span id='C-Instrument-method-mapChord'>    /**
</span>     * Map a chord on this instrument. This function creates
     * the posible chord positions. Internaly it will call:
     *     - _initChordData
     *     - _procChord
     *     - _slideWindow
     *     - _setDifficulty
     *     - _sortChordPos
     * 
     * @param {C.Chord} c
     */
    mapChord: function(c){
	this.c.chord=c;
	this._initChordData();
	this._procChord();
// 	lg(this._splitFormulaDbgStr());
	
	this._slideWindow();
	this._setDifficulty();
	this._sortChordPos();
// 	C.ChordRep.dbgPrintArray(this.c.pos,true)
	
	return this;
	
    },
    
<span id='C-Instrument-method-_initChordData'>    /**
</span>     * Init chord data structure and reset any previous data.
     * 
     * @private
     */
    _initChordData: function(){
	
	// Init data
	this.c.form = this.c.chord.getFormula();
	this.c.fsplit = this.c.form.split(&quot; &quot;);
	
	this.c.notes = new Array();
	this.c.fpos   = new Array();
	this.c.pos   = new Array();
	
	return this
    },
    
<span id='C-Instrument-method-_procChord'>    /**
</span>     * Process chord and find the positions for each formula 
     * part on each string.
     * 
     * @private
     */ 
    _procChord: function(){
	
	// Find all positions for all sub-notes in chord
	for (var fp = 0; fp&lt;this.c.fsplit.length; fp++) {
	    
	    var tmpFp = this.c.fsplit[fp];
// 	    lg(&quot;Formula: &quot;+tmpFp)
// 	    this.c.fpos[fp] = new Array();
	    
	    
	    // Formula note... (from root of this chord)
	    var note = this.c.chord._formulaToNote(tmpFp);
	    this.c.notes.push (note);
	    
	    // Sort ths: Check for 9th,11th, etc
	    if (tmpFp.indexOf('9')!==-1)
		this.c.th9 = note.toString();
	    else if (tmpFp.indexOf('11')!==-1)
		this.c.th11 = note.toString();
	    else if (tmpFp.indexOf('13')!==-1)
		this.c.th13 = note.toString();
	    
// 	    lg(&quot;Target Note: &quot;+note.toString())
		
	    // For each string
	    for (var i=0; i&lt;this.getNumStrings(); i++){
		if (!this.c.fpos[i]) this.c.fpos[i]=[-1];
		
// 		lg(&quot;String: &quot;+this.options.strings[i])
		// String root note
		var rootNote = this.getStringRoot(i);
		
		var rIdx = rootNote.getIdx();
		var nIdx = note.getIdx();
		
		
		// Find the 1st position after the root
		var first;
		
		if (nIdx &gt;= rIdx) 
		    first = parseInt(nIdx-rIdx);
		else 
		    first = parseInt((C.NOTES.length - rIdx)+nIdx);
		
		// Expand to the number of frets
		while (first&lt;=this.options.numFrets+this.options.maxFretSpan){
		    if (this.c.fpos[i].hasItem(first)) continue;
		    this.c.fpos[i].push(first);
		    first+=C.NOTES.length;
		}
		
// 		lg(&quot;Pos: &quot;+this.c.pos[fp][i]);
	    }
	}
	
	return this
	
    },
    
    
<span id='C-Instrument-method-_splitFormulaDbgStr'>    /**
</span>     * Debug print the result of _procChord function
     * @private
     */
    _splitFormulaDbgStr: function(){
	var str = &quot;For each formula part on a per string basis.\n&quot;;
	for (var i=0; i&lt;this.getNumStrings(); i++){
	    str+=i+&quot;=[&quot;+this.c.fpos[i].join(&quot; &quot;)+&quot;] \n&quot;;
	}
	
	return str;
    },
    
    
    
<span id='C-Instrument-method-getNoteForString'>    /**
</span>     * Get a note given the string number and the offset on it... 
     * If -1 is given, the root note of the string is returned 
     * with -1 playable index.
     * 
     * @param {Number} s String index (from pos) 
     * @param {Number} offset Offset 
     * @return {C.Note} 
     */
    getNoteForString: function(s, offset){
	var cNote = this.getStringRoot(s,(offset==-1));
	if (offset==-1) cNote.setNote(&quot;-&quot;);
	return cNote.offset(offset);
    },
    
<span id='C-Instrument-method-getStringRoot'>    /**
</span>     * Return to root not for string s. If noPlayable is set
     * it will not attempt to set playable position... This is
     * needed for getPlayableOffForString which causes a loop
     * 
     * NOTE: Do not cache root notes, cause then we need to clone
     * them, which takes a lot longer than creating...
     * 
     * @param {Number} s String index
     * @param {Boolean} noPlayable If true do not set playble offset
     * @return {C.Note}
     */
    getStringRoot: function(s, noPlayable) {
	var newNote = new C.Note({
	    note: this.options.strings[s].toUpperCase()
	});
	
	if (!noPlayable)
	    newNote.options.playPos = this.getPlayableOffForString(s, 0)
	 
	return newNote;
    },
    
<span id='C-Instrument-method-getPlayableOffForString'>    /**
</span>     * Get playable note offset given a string and the offset
     * on that string
     * 
     * @param {Number} s String index
     * @param {Number} offset 
     * @return {Number}
     */
    getPlayableOffForString: function(s,offset){
	var idx = offset;
	
	for (var i=0; i&lt;s; i++) {
	    // Get roots WITHOUT PLAYABLE OFFSETS
	    var r1 = this.getStringRoot(i,true).getIdx();
	    var r2 = this.getStringRoot(i+1,true).getIdx();
	    
	    if (r2&lt;r1) 
		r2 += C.NOTES.length;

	    var diff = r2-r1;
	    
	    idx+=diff;
	}
	
	return idx;
    },

<span id='C-Instrument-method-_setDifficulty'>    /**
</span>     * Generic difficulty. A very basic function tobe used 
     * for initial sorting. Specific instruments should override 
     * this.
     * 
     * @private
     */
    _setDifficulty: function() {
	for (var i=0; i&lt;this.c.pos.length; i++){
	    var c = this.c.pos[i];
	    var diff = c.span()*5/this.options.maxFretSpan;
	    var uniq = c.pos.unique().length;
	    diff+=uniq;
	    diff/=2;
	    c.setDiff(diff);
	}
	
	return this;
    },
    
<span id='C-Instrument-method-_checkChord'>    /**
</span>     * Check if a chord is valid. Make sure that all sub-tones from the 
     * chords formula exist in the given positions. This function also
     * supports optional pitches (ie (9) ) in the formula.
     * 
     * TODO: Add 9ths rules...
     * 
     * @param {C.ChordRep} chord
     * @private
     */
    _checkChord: function(chord){
	// Array of STRINGS!
	var foundNotes = [];
	var root=-1;
	
	// Per string
	for (var i=this.getNumStrings()-1; i&gt;=0; i--) {
	    if (chord.getPos(i)==-1) 
		continue;

	    var n = chord.getNote(i).toString();

	    // Detect ROOT
	    var po = chord.getNote(i).options.playPos;
	    if (root==-1 &amp;&amp; n==this.c.chord.getRoot()) {
		root=chord.getNote(i).options.playPos;
	    }
	    
	    // 9ths,etc
	    if (root &amp;&amp; (n==this.c.th9 || n==this.c.th11 || n==this.c.th13)
		&amp;&amp; (po-root&lt;C.NOTES.length)
	    ) {
		// another 9th may exist later?
		continue;
		// return false; // Safer, may skip some postions...
	    }
		
	    if (!foundNotes.hasItem(n.toString()))
		foundNotes.push(n.toString());
	    
	    // Check that all formula parts are there
	    if (foundNotes.length === this.c.notes.length)
		return true;
	    
	}
	
	// Check for optionals...
	var countCompalsory = 0;
	var countCompalsoryChord = 0;
	
	for (var i=0; i&lt;this.c.fsplit.length; i++) {
	    // if optional continue...
	    if (this.c.fsplit[i].indexOf(&quot;(&quot;)!=-1)
		continue;
	    
	    countCompalsory++;
	    if (foundNotes.hasItem(this.c.notes[i].toString())) {
		countCompalsoryChord++;
	    }
	    
	}
	
	return (countCompalsoryChord==countCompalsory);
    },
    
<span id='C-Instrument-method-getNumPos'>    /**
</span>     * Get the number of positions for the current
     * chord mapped on this instrument
     * 
     * @return {Number}
     */
    getNumPos: function(){
	return this.c.pos.length
    },
    
    
<span id='C-Instrument-method-getPosIdx'>    /**
</span>     * Get current plotted position (if any)
     * 
     * @return {Number} 
     */
    getPosIdx: function(){
	return this.c.diag.idx
    },
    
<span id='C-Instrument-method-getChordPos'>    /**
</span>     * Get chord representation at the specified index
     * 
     * @param {Number} idx
     * @return {C.ChordRep}
     */
    getChordPos: function(idx){
	if (idx&lt;0) idx=0;
	if (idx&gt;=this.c.pos.length) idx=this.c.pos.length-1;
	
	return this.c.pos[idx];
    },
    
<span id='C-Instrument-method-_sortChordPos'>    /**
</span>     * Sort chord positions based on their difficulty
     * @private
     */
    _sortChordPos: function(){
	this.c.pos.sort(function(a,b){
	    return (a.getDiff()-b.getDiff())
	});
	
	return this;
    },
    
    
    //--------------------------------
    // Plotting/GUI
    //--------------------------------
    
<span id='C-Instrument-method-diagram'>    /**
</span>     * Base of diagram, ensure that what is a chord representation
     * and store info. This function is responsible for calling the 
     * correct plotter based on the options object.
     * 
     * @param {C.ChordRep/Number} Index of chord or ChordRep to plot
     * @param {HTMLElement} el
     * @param {Object} opts Options
     */
    diagram: function(what,el,opts){
	
	el = (el) ? el : this.c.diag.el;
	
	this.c.diag.el = el;
	
	// Accept eiter chord representation or
	// position 
	if (!(what instanceof C.ChordRep)) {
	    if (this.c.pos.length==0) return false;
	    if (what&lt;0) what=0;
	    if (what&gt;=this.c.pos.length) what=this.c.pos.length-1;
			      
	    // Store
	    this.c.diag.idx = what;
	    what = this.c.pos[what];
	}
	
	var t = C.Util.objValue(opts, &quot;type&quot;, &quot;html&quot;);
	
	switch (t) {
	    case &quot;html&quot;:
		return this.diagramHTML(what,el,opts);
	    default:
		throw new Error({'C.Instrument':'Diagram type &quot;'+t+'&quot; is not known...'}) 
	}
	
	return this;
    },
    
<span id='C-Instrument-method-diagramNext'>    /**
</span>     * Show next chord from the available positions
     * 
     * @return {Boolean} True if next exists
     */
    diagramNext: function(){
	if (this.c.diag.idx==-1 || !this.c.diag.el) return false;
	this.diagram(this.c.diag.idx+1);
	return true;
    },
    
<span id='C-Instrument-method-diagramPrev'>    /**
</span>     * Show prev chord
     * @return {Boolean} True if previous exists
     */
    diagramPrev: function(){
	if (this.c.diag.idx==-1 || !this.c.diag.el) return false;
	this.diagram(this.c.diag.idx-1);
	return true;
    }
});






</pre>
</body>
</html>
