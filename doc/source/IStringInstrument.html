<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">
<span id='C-IStringInstrument'>/**
</span> * Base class for all string instruments. Mainly 
 * diagram plotting happens here
 * 
 * @class 
 * @extends C.Instrument
 */
C.IStringInstrument = C.Instrument.extend({
    
        
<span id='C-IStringInstrument-method-isChordPlayable'>    /**
</span>     * Return true if the chord is playable. This is decided based on the 
     * instrument parameters. Skilled players may need to create new instruments
     * but this should cover most ppl.
     * 
     * The parameters are supplied via options in the constructor and they are:
     * 
     *    - hasBar: true/false, If the instrument supports bar chords... with a bar 
     * chord the minimum duplicate pos is considered to be occuping 1 finger
     * 
     *    - ignoreTone0: true/false, Mainly true for string instruments. The 0 is 
     * considered open and does nto need a finger (used also in _slideWindow)
     * 
     *    - maxPlayableTones: 4/5, Usually the same number as the fingers?!
     *  
     *     - maxFretSpan: 4, how many frets a chord can occupy (width)
     * 
     * @param {C.ChordRep} c
     * @return {Boolean}
     */
    isChordPlayable: function(c) {
	
	// Check span!
	if (c.span()&gt;=this.options.maxFretSpan) return false;
	
	var dup = c.getMinDuplicate();
	
	// Do the basic checking and see if this can be played 
	// as bare
	var higherDup = false;
	var lowerDup = false;
	var count=0;
	for (var i=0; i&lt;c.size(); i++){
	    if (c.getPos(i)==-1) 
		continue;
	    
	    // Register tone...
	    
	    // 0 doesnt count in the tones...
	    if (c.getPos(i)!=0 || !this.options.ignoreTone0) {
		count++
	    }
	    
	    // Bar stuff...
	    if (dup&gt;0) {
		if (dup&lt;c.getPos(i)) higherDup=true;	// Higher note than the min duplicate
		if (dup&gt;c.getPos(i)) lowerDup=true;	// Lower note than the min duplicate
	    }
	}
	
	// Now do the Math...
	var bar = (dup&gt;0 &amp;&amp; lowerDup!=true);
	var finalCount = count;
	if (bar &amp;&amp; this.options.hasBar) 
	    finalCount=count - c.countNum(dup) +1;
// 	lg(c+&quot; &quot;+finalCount)
	var playable = (finalCount &lt;= this.options.maxPlayableTones);
	
	if (!playable) return false;
	return true;
	
    },
    
<span id='C-IStringInstrument-method-_slideWindow'>    /**
</span>     * Make all the posible string/fret combinations that include notes
     * from the chords' formula. This is actually done recursively calling 
     * __doRecursion
     * 
     * @private
     */
    _slideWindow: function(){

	    
	// For each string! set the the first postion and do all
	// combos for the next string!
	this.__doRecursion(
		0, 
		new C.ChordRep.getEmpty(this.getNumStrings(), this)
	    );
	
	return this;
    },
    
<span id='C-IStringInstrument-method-__doRecursion'>    /**
</span>     * Make all the posible string/fret combinations (recursively) that 
     * include notes from the chords' formula
     * 
     * @param {Number} s Index of string
     * @param {C.ChordRep} chord Chord built at the current stage
     * @private
     */
    __doRecursion: function(s,chord){
// 	var tab = &quot;&quot;;
// 	for (var t=0; t&lt;s; t++) tab+=&quot; &quot;;
// 	lg (&quot;\n&quot;+tab+&quot;Rec s=&quot;+(s)+&quot;/&quot;+this.getNumStrings()+&quot; &quot;+chord)
	
	// Static max/min to reduce function call
	// on recursion
	var minS = chord.minPos();
	var maxS = chord.maxPos();
	var empty = chord.isEmpty();
	
	// For the rest of the strings...
	for (var p=0; p&lt;this.c.fpos[s].length; p++){
// 	    lg(tab+s+&quot;:&quot;+p)
	    var tmp_pos = this.c.fpos[s][p];
	
	    if (!empty) {
	    
		var min = minS;
		var max = maxS;
		
		if ((tmp_pos!=0 &amp;&amp; tmp_pos!=-1) || (tmp_pos==0 &amp;&amp; !this.options.ingoreTone0)){
		    if (max&lt;tmp_pos) max=tmp_pos;
		    if (min&gt;tmp_pos) min=tmp_pos;
		}
		if (max-min &gt; this.options.maxFretSpan) {
// 		    lg(tab+&quot;Skipping pos=&quot;+tmp_pos+&quot; max=&quot;+max+&quot; min=&quot;+min)
		    continue;
		}
	    }
	    
	    // Clone: Do NOT change the base
	    var newChord = chord.clone();
	    newChord.setPos(s,tmp_pos);
	    newChord.setNote(s, this.getNoteForString(s, tmp_pos));
		
	    // Current string was the last
	    if (s==this.getNumStrings()-1) {
		newChord=this._checkBase(newChord, this.c.chord.getRoot());

		if (newChord.isEmpty()     || 
		    this._chordPosExists(newChord)   || 
		    !this.isChordPlayable(newChord) ||
		    !this._checkChord(newChord) ) {
// 		    lg (tab+&quot;Failing: &quot;+newChord +this._chordPosExists(newChord))
		    continue;
		}
		
		
		// Assuming we got everything now...
// 		lg (tab+&quot;Adding: &quot;+newChord)
		this.c.pos.push(newChord);
	    } 
	    else {
		this.__doRecursion(s+1, newChord.clone());
	    }
// 	    lg(tab+&quot;-&quot;+p)
	}
	return this;
    },
    
<span id='C-IStringInstrument-method-_getVariations'>    /**
</span>     * Return all partial positions for this chord given
     * the number of tones/piches in it
     * 
     * @return {Array/Boolean} false if not partials exist
     * @deprecated
     * @private
     */
    _getVariations: function(data, chord){
	var variations = [];
	var foundNotes = [];
	var complete = false;
	
	
	for (var i=this.getNumStrings()-1; i&gt;=0; i--) {
	    if (chord.getPos(i)==-1) {
		continue;
	    }

	    var n = chord.getNote(i).toString();
	    if (!foundNotes.hasItem(n))
		foundNotes.push(n);
	    
	    // Check that all formula parts are there
	    if (!complete &amp;&amp; foundNotes.length === data.notes.length){
		var complete = true;
	    }
	    
	    // Now if all there and base is correct add as variation 
	    var tmpChord = chord.getPartialHigher(i);

	    if (complete &amp;&amp; // complete
		data.chord.getRoot()==n &amp;&amp; // correct base
		!tmpChord.isEmpty() &amp;&amp; // not the last string
		!chord.isEmptyTill(i) &amp;&amp;
		i!=0
		)
	    {
		variations.push(tmpChord);
	    }
	}
	
	if (!complete) return false;
	return variations;
    },
    
<span id='C-IStringInstrument-method-_checkBase'>    /**
</span>     * Check that the chord start with the base note...
     * MAYBE: Optional?
     * 
     * @param {C.ChordRep} c
     * @param {C.Note} root
     * @private
     */
    _checkBase: function(c,root){
	
	for (var s=c.getBasePos(); s&lt;c.size(); s++){
	    // Skip strings we dont play
	    if (c.getPos(s)==-1) 
		continue;
	    
	    var note = this.getStringRoot(s);
	    note.offset(c.getPos(s));
	    
	    if (note.toString()!=root) {
		c.setPos(s,-1);
	    }else {
		break;
	    }
	    
	}
	
	return c;
    },
    
    
<span id='C-IStringInstrument-method-_chordPosExists'>    /**
</span>     * Return true if the given chord already exists in the
     * chord structure
     * 
     * @param {C.ChordRep} c
     * @return {Boolean}
     * @private
     */
    _chordPosExists: function(c){
	for (var p=0; p&lt;this.getNumPos(); p++){
	    if (c.equal(this.getChordPos(p)))
		return true;
	}
	
	return false;
    },
    
<span id='C-IStringInstrument-method-_setDifficulty'>    /**
</span>     * Set all chord positions difficulty for string-based instruments
     * 
     * @private
     */
    _setDifficulty: function(){
	var maxDiff = -1;
	var minDiff = 10000;
	
	// Set score
	for (var i=0; i&lt;this.getNumPos(); i++){
	    var c = this.getChordPos(i)
	    var diff = this.getChordDiff(c);
	    if (diff&lt;minDiff) minDiff=diff;
	    if (diff&gt;maxDiff) maxDiff=diff;
	    c.setDiff(diff);
	}
	
	// Normalize scores... optional
	
	return this;
    },
    
<span id='C-IStringInstrument-method-getChordDiff'>    /**
</span>     * 
     * Get chords difficulty
     * 
     * Change and loop:
     *     - Higher priority chords on top
     *     - UnInterapted patters (x ONLY)
     *     - Make sure the distance between fret and o is small
     *     - Make sure a base string is played!
     *     - Span, the sorter the better
     *     - Number of position &lt; the better
     * 
     * TODO:FIXME: This does not work very well... find another way
     * 
     * @param {C.ChordRep} c
     * @return {Number}
     */
    getChordDiff: function(c){
	var min = 100000;
	var max = -1;
	var countXinBetween = 0;
	var countX = 0;
	var countXTotal = 0;
	var countOinBetween = 0;
	var countO = 0;
	var countOTotal = 0;
	var foundPress = false;
	
	for (var s=0; s&lt;c.size(); s++) {
	    var cur = c.getPos(s);
	    
	    // MaxMin
	    if (cur&gt;0 &amp;&amp; cur&lt;min) min=cur;
	    if (cur&gt;max) max=cur;
	    
	    // Handle 0/-1
	    if (cur&gt;-1) {
		// If 1st playable, discart OX
		if (!foundPress) {
		    countO=0;
		    countX=0;
		}
		foundPress=true; 
		// Add all previous...
		countXinBetween+=countX;
		countX=0;
		if (cur!=0) {
		    countOinBetween+=countO;
		    countO=0;
		}
		else {
		    countO++;	// this resets
		    countOTotal++;	// this doesn't
		}
	    }
	    else if (cur==-1) {
		countX++;	// this resets
		countXTotal++;	// this doesn't
	    }
	}
	
	// We should be OK here!
// 	lg (c+&quot;:&quot;+countXTotal+&quot; &quot;+ countXinBetween+&quot;, &quot;+countOTotal+&quot; &quot;+ countOinBetween+&quot;, &quot;+min+&quot; &quot;+max)
	
	var score=50; // out of 100
	// An Open is good
	score -= (countOTotal)*5;
	// ... however an open in between is worse
	score += countOinBetween*10;
	// and all open is also Bad boy...
	if (max==0) score+=60;
	
	// X in the middle is very bad
	score += countXinBetween*20;
	// Small Penalty for not playing strings...
	score += (countXTotal-countXinBetween)*4;
	
	// Bar is bad!
	if (c.isBar()) score += 20;
	// However (full bar)
	if (c.isBar() &amp;&amp; !countXinBetween &amp;&amp; !countOinBetween) score -= 20;
	  
	    
	// Use less a bit long open
	if (countOTotal&gt;0 &amp;&amp; max&gt;5) score+= (max -5)*3;
					  
	// The longer it spans the more diff
	if (max!=0) score+=(max-min)*5;
	
	
	
	
	// The Higher the better! (If no shit in the between)
	// just fractions for Fs...
// 	if (!countXinBetween &amp;&amp; !countOinBetween)
// 	    score+=(min);
	
	// Playing a base is good...
	// Penalty chords that do not have one...
	if (c.getBasePos()&gt;=this.getNumStrings()/2) score+=c.getBasePos()*5;
					  
					  
	
	return score;
	
    },
    
<span id='C-IStringInstrument-method-diagramHTML'>    /**
</span>     * Make current set chord diagram in an HTML element
     * 
     * @param {C.ChordRep} what
     * @param {HTMLElement} el
     * @param {Object} opts
     */
    diagramHTML: function(what,el,opts){
	
	el = (el) ? el : this.c.diag.el;
	if (what===false) return false;
	
	C.DomUtil.empty(el);
	var base = this._getBaseTable();
	var idx = base[1];
	
	// Title
	idx[0][1].textContent = this.c.chord.toString();
	
	// First fret &amp;&amp; Fretboard start!
	var numStrings = this.getNumStrings();
	var f = what.minPos();
	
	// We start from top
	if (f&lt;=1 || what.maxPos()&lt;=this.options.maxFretSpan+1){
	    f=&quot;&quot;
	    for (var i=1; i&lt;numStrings; i++)
		C.DomUtil.addClass(idx[1][i], &quot;c_fretstart&quot;);
	}
	idx[2][0].textContent = f;
	var root = this.c.chord.getRoot().toString();
	
	// Add the chord
	for (var i=0; i&lt;numStrings; i++){
	    
	    // See if root
	    var tmpNote = what.getNote(i).toString();
	    var cls=&quot;&quot;;
	    if (tmpNote==root) 
		cls=&quot; root&quot;;
	    
	    
	    if (what.getPos(i)==0) {
		C.DomUtil.create(&quot;span&quot;,cls,idx[1][i]).textContent = &quot;o&quot;;
		continue;
	    }
	    if (what.getPos(i)==-1) {
		C.DomUtil.create(&quot;span&quot;,&quot;&quot;,idx[1][i]).textContent = &quot;x&quot;;
		continue;
	    }
	    var idxpos = what.getPos(i);
	    
	    if (what.maxPos()&gt;this.options.maxFretSpan+1)
		idxpos = what.getPos(i) - what.minPos() +1; // start from 0 fret + headers
	    
	    var dot = C.DomUtil.create(&quot;div&quot;,&quot;guitardot&quot;+cls,idx[idxpos+1][i+1]);
	    dot.innerText = tmpNote;
	}
	
	el.appendChild(base[0]);
	
	return this;
    },
    
    
<span id='C-IStringInstrument-method-_getBaseTable'>    /**
</span>     * Helper function to get the basic HTML table to be used for plotting
     * the chord on...
     * 
     * @return {Array} of DOMElement (table) and index of all it's cells
     * @@private
     */
    _getBaseTable: function(){
	var t = C.DomUtil.create('table','c_guitar_diagram noselect');
	var idx = [];
	
	// 1st line - title
	idx[0] = [];
	var cell = C.DomUtil.create('tr','',t);
	idx[0][0] = C.DomUtil.create('td','',cell); // wasted column
	idx[0][1] = C.DomUtil.create('td','c_chord_title',cell); // title
	idx[0][1].colSpan = this.getNumStrings()-1;
	
	var numStrings = this.getNumStrings();
	
	// The rest!
	for (var row=1; row&lt;2+this.options.maxFretSpan+1; row++) {
	    idx[row] = [];
	    var cell = C.DomUtil.create('tr','',t);
	    for (var i=0; i&lt;numStrings+1; i++) {
		var cls = &quot;&quot;;
		if (row==1) cls=&quot;c_openclose&quot;
		else if (row&gt;1 &amp;&amp; i&gt;0 &amp;&amp; i&lt;numStrings) cls=&quot;c_fret_cell&quot;
		
		// Style Extensions
		if (row==2 &amp;&amp; i&gt;0 &amp;&amp; i&lt;numStrings) cls+=&quot; c_fret_cell_top&quot;;
		if (row==numStrings &amp;&amp; i&gt;0 &amp;&amp; i&lt;numStrings) cls+=&quot; c_fret_cell_bottom&quot;;
		if (row&gt;1 &amp;&amp; i==1) cls+=&quot; c_fret_cell_1st&quot;
		
		idx[row][i] = C.DomUtil.create('td',cls,cell);
	    }
	}
	return [t,idx];
    },
    
    
<span id='C-IStringInstrument-method-drawInstrument'>    /**
</span>     * Create full the fretboard, if applicable. Store
     * the HTML elements on this.fretboard to be able to 
     * clear without redrawing
     * 
     * @param {HTMLElement} el
     * @param {Object} opts
     * @param {String} opts.cssClass Base css class
     * @param {Boolean} opts.changeSize Change string size
     * @param {Function} opts.fretClick Callback for on click on fret
     * @return {Array} index
     */
    drawInstrument: function(el,opts){
	
	if (this.fretboard!==undefined) return;
	
	C.DomUtil.empty (el);
	var numStrings = this.getNumStrings();
	var numFrets = this.options.numFrets;
	
	// Base css class
	var cls = C.Util.objValue(opts, &quot;cssClass&quot;, &quot;g_fret_s&quot;);
	
	if (this.options.doubleString) cls+=&quot;d&quot;;
	
	// Create base table
	var t = C.DomUtil.create('table','c_guitar_fretboard noselect');
	var idx = [];
	
	var cb = C.Util.objValue(opts, &quot;fretClick&quot;, false);
	
	for (var s=0; s&lt;numStrings; s++){
	    
	    idx[s] = [];
	    var row = C.DomUtil.create('tr','',t);
	    idx[s][0] = C.DomUtil.create('td',&quot;g_fret_open&quot;,row);
	    idx[s][0].setAttribute(&quot;data-string&quot;,s);
	    idx[s][0].setAttribute(&quot;data-fret&quot;,0);
	    if (cb) idx[s][0].onclick = cb;
	    
	    var clsExtra = &quot;&quot;;
	    if ( C.Util.objValue(opts, &quot;changeSize&quot;, false))  clsExtra = &quot; s&quot;+(s+1);
	    
	    for (var f=1; f&lt;numFrets+2; f++){
		idx[s][f] = C.DomUtil.create('td',cls+clsExtra,row);
		idx[s][f].setAttribute(&quot;data-string&quot;,s);
		idx[s][f].setAttribute(&quot;data-fret&quot;,f);
		if (cb) idx[s][f].onclick = cb;
	    }
	}
	
	idx[numStrings] = [];
	var row = C.DomUtil.create('tr','',t);
	for (var f=0; f&lt;numFrets+2; f++){
	    idx[numStrings][f] = C.DomUtil.create('td',&quot;g_fret_num&quot;,row);
	    // dot pattern...
	    if ((f!=1 &amp;&amp; f%2!=0 &amp;&amp; f!=11 &amp;&amp; f!=13) || f==12) idx[numStrings][f].innerText=f;
	}
	
	el.appendChild(t);
	
	this.fretboard = idx;
	
	return this;
    },
    
<span id='C-IStringInstrument-method-drawScale'>    /**
</span>     * Draw the whole scale on the fretboard. 
     * 
     * TODO: extend with boxes
     */
    drawScale: function(scale,opts,el){
	this.drawInstrument(el,opts);
	var idx = this.fretboard;
	var notes = scale.getNotes();
	
	for (var n=0; n&lt;notes.length; n++) {
	    
	    // create the correct class for this note
	    var cls=&quot;&quot;;
	    if (n==0) cls=&quot; root&quot;;
	    
	    for (var s=0; s&lt;this.getNumStrings(); s++) {
		
		// Get all positions of this not on this string
		var pos = this.getFretsFor(notes[n],s,this.options.numFrets+1);
		
		// Add them
		for (var p=0; p&lt;pos.length; p++) {
		    var dot = C.DomUtil.create(&quot;div&quot;,&quot;guitardot&quot;+cls,idx[this.getNumStrings()-s-1][pos[p]]);
		    dot.innerText = notes[n].toString();
		}
	    }
	}
	
	return this;
    },
    
<span id='C-IStringInstrument-method-clearScale'>    /**
</span>     * Clear the current scale if any
     */
    clearScale: function(){
	var f = this.fretboard;
	
	if (!f) return;
	
	for (var i=0; i&lt;f.length; i++){
	    for (var j=0; j&lt;f[i].length; j++){
		C.DomUtil.empty(f[i][j]);
	    }
	}
    },
    
    drawChordOnInstrument: function(what,el,opts){
    }
}); 
</pre>
</body>
</html>
